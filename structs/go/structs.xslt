<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" version="1.0">
  <xsl:output method="text" encoding="utf-8" omit-xml-delaration="yes" indent="no"/>
  <xsl:variable name="newline">
    <xsl:text>&#xa;</xsl:text>
  </xsl:variable>
  <xsl:variable name="tab">
    <xsl:text>&#09;</xsl:text>
  </xsl:variable>
  <xsl:template match="/">
    <xsl:apply-templates/>
  </xsl:template>
  <xsl:template match="xs:schema">
    <xsl:text><![CDATA[// DO NOT EDIT
// This file was machine generated by github.com/wamuir/procurement-data-standard/structs/go

// Package pds defines Golang types for the Procurement Data Standard (xs:schema/@version="]]></xsl:text>
    <xsl:value-of select="@version"/>
    <xsl:text><![CDATA[").
package pds

import (
	"encoding/xml"
	"fmt"
	"time"
)

type XsBase64Binary string

func (x XsBase64Binary) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%s", x), start)
}

func (x *XsBase64Binary) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsBase64Binary(v)
	return nil
}

type XsDate time.Time

func (x XsDate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	v := time.Time(x)
	return e.EncodeElement(v.Format("2006-01-02"), start)
}

func (x *XsDate) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	t, err := time.Parse("2006-01-02", v)
	if err != nil {
		return err
	}

	*x = XsDate(t)
	return nil
}

type XsDecimal float64

func (x XsDecimal) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%f", x), start)
}

func (x *XsDecimal) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v float64
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsDecimal(v)
	return nil
}

type XsFloat float64

func (x XsFloat) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%f", x), start)
}

func (x *XsFloat) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v float64
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsFloat(v)
	return nil
}

type XsGYearMonth time.Time

func (x XsGYearMonth) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	v := time.Time(x)
	return e.EncodeElement(v.Format("2006-01"), start)
}

func (x *XsGYearMonth) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	t, err := time.Parse("2006-01", v)
	if err != nil {
		return err
	}

	*x = XsGYearMonth(t)
	return nil
}

type XsInteger int64

func (x XsInteger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%d", x), start)
}

func (x *XsInteger) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v int64
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsInteger(v)
	return nil
}

type XsNonNegativeInteger int64

func (x XsNonNegativeInteger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%d", x), start)
}

func (x *XsNonNegativeInteger) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v int64
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsNonNegativeInteger(v)
	return nil
}

type XsNonPositiveInteger int64

func (x XsNonPositiveInteger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%d", x), start)
}

func (x *XsNonPositiveInteger) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v int64
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsNonPositiveInteger(v)
	return nil
}

type XsPositiveInteger int64

func (x XsPositiveInteger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%d", x), start)
}

func (x *XsPositiveInteger) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v int64
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsPositiveInteger(v)
	return nil
}

type XsString string

func (x XsString) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%s", x), start)
}

func (x *XsString) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsString(v)
	return nil
}

type XsTime time.Time

func (x XsTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	v := time.Time(x)
	return e.EncodeElement(v.Format("2006-01-02T15:04:05"), start)
}

func (x *XsTime) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	t, err := time.Parse("2006-01-02T15:04:05", v)
	if err != nil {
		return err
	}

	*x = XsTime(t)
	return nil
}

type XsToken string

func (x XsToken) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.EncodeElement(fmt.Sprintf("%s", x), start)
}

func (x *XsToken) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	if err := d.DecodeElement(&v, &start); err != nil {
		return err
	}

	*x = XsToken(v)
	return nil
}

type CDATA struct {
	Value XsString `xml:",cdata"`
}]]></xsl:text>
    <xsl:apply-templates select="xs:element" mode="typeDef"/>
    <xsl:apply-templates select="xs:group" mode="typeDef"/>
    <xsl:apply-templates select="xs:complexType" mode="typeDef"/>
    <xsl:apply-templates select="xs:simpleType" mode="typeDef"/>
  </xsl:template>
  <xsl:template match="xs:element" mode="typeDef">
    <xsl:value-of select="$newline"/>
    <xsl:apply-templates select=".">
      <xsl:with-param name="prefix">
        <xsl:text>type </xsl:text>
      </xsl:with-param>
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="xs:group" mode="typeDef">
    <xsl:value-of select="$newline"/>
    <xsl:apply-templates select=".">
      <xsl:with-param name="prefix">
        <xsl:text>type </xsl:text>
      </xsl:with-param>
    </xsl:apply-templates>
    <xsl:value-of select="$newline"/>
  </xsl:template>
  <xsl:template match="xs:complexType" mode="typeDef">
    <xsl:value-of select="$newline"/>
    <xsl:apply-templates select=".">
      <xsl:with-param name="prefix">
        <xsl:text>type </xsl:text>
      </xsl:with-param>
    </xsl:apply-templates>
    <xsl:value-of select="$newline"/>
  </xsl:template>
  <xsl:template match="xs:simpleType" mode="typeDef">
    <xsl:value-of select="$newline"/>
    <xsl:apply-templates select=".">
      <xsl:with-param name="prefix">
        <xsl:text>type </xsl:text>
      </xsl:with-param>
    </xsl:apply-templates>
    <xsl:value-of select="$newline"/>
  </xsl:template>
  <xsl:template match="xs:annotation">
    <xsl:param name="indent"/>
    <xsl:if test="translate(normalize-space(xs:documentation/text()), ' ', '')">
      <xsl:value-of select="$indent"/>
      <xsl:text>// </xsl:text>
      <xsl:value-of select="translate(normalize-space(xs:documentation/text()), ' ', '')"/>
      <xsl:value-of select="$newline"/>
    </xsl:if>
  </xsl:template>
  <xsl:template match="xs:element">
    <xsl:param name="indent"/>
    <xsl:param name="prefix"/>
    <xsl:param name="choice"/>
    <xsl:value-of select="$newline"/>
    <xsl:if test="xs:annotation">
      <xsl:apply-templates select="xs:annotation">
        <xsl:with-param name="indent">
          <xsl:value-of select="$indent"/>
        </xsl:with-param>
      </xsl:apply-templates>
    </xsl:if>
    <xsl:value-of select="$indent"/>
    <xsl:value-of select="$prefix"/>
    <xsl:value-of select="translate(@name, '-', '_')"/>
    <xsl:variable name="type-prefix">
      <xsl:choose>
        <xsl:when test="(@minOccurs &gt; 1) or (@maxOccurs &gt; 1) or (@maxOccurs = 'unbounded')">
          <xsl:text>[]</xsl:text>
        </xsl:when>
        <xsl:when test="@minOccurs = 0">
          <xsl:text>*</xsl:text>
        </xsl:when>
        <xsl:when test="$choice = 'true'">
          <xsl:text>*</xsl:text>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="@name = 'FormattedClauseFullText'">
        <xsl:text> </xsl:text>
        <xsl:value-of select="$type-prefix"/>
        <xsl:text>CDATA</xsl:text>
      </xsl:when>
      <xsl:when test="@type">
        <xsl:text> </xsl:text>
        <xsl:value-of select="$type-prefix"/>
        <xsl:apply-templates select="@type"/>
      </xsl:when>
      <xsl:when test="*[not(self::xs:annotation)]">
        <xsl:apply-templates select="*[not(self::xs:annotation)]">
          <xsl:with-param name="indent">
            <xsl:value-of select="$indent"/>
          </xsl:with-param>
          <xsl:with-param name="prefix">
            <xsl:text> </xsl:text>
            <xsl:value-of select="$type-prefix"/>
          </xsl:with-param>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text> </xsl:text>
        <xsl:value-of select="$type-prefix"/>
        <xsl:text>XsString</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:value-of select="$newline"/>
  </xsl:template>
  <xsl:template match="xs:simpleType">
    <xsl:param name="indent"/>
    <xsl:param name="prefix"/>
    <xsl:param name="choice"/>
    <xsl:if test="xs:annotation">
      <xsl:apply-templates select="xs:annotation">
        <xsl:with-param name="indent">
          <xsl:value-of select="$indent"/>
        </xsl:with-param>
      </xsl:apply-templates>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$prefix = 'type '">
        <!-- Type definition -->
        <xsl:value-of select="$prefix"/>
        <xsl:value-of select="translate(@name, '-', '_')"/>
        <xsl:text> </xsl:text>
        <xsl:apply-templates select="xs:restriction/@base"/>
        <!-- MarshalXML method -->
        <xsl:value-of select="$newline"/>
        <xsl:value-of select="$newline"/>
        <xsl:apply-templates select="." mode="marshal"/>
        <!-- UnmarshalXML method -->
        <xsl:value-of select="$newline"/>
        <xsl:value-of select="$newline"/>
        <xsl:apply-templates select="." mode="unmarshal"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$prefix"/>
        <xsl:if test="@name">
          <xsl:value-of select="translate(@name, '-', '_')"/>
          <xsl:text> </xsl:text>
        </xsl:if>
        <xsl:apply-templates select="xs:restriction/@base"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template match="xs:simpleContent">
    <xsl:param name="indent"/>
    <xsl:param name="prefix"/>
    <xsl:if test="xs:annotation">
      <xsl:apply-templates select="xs:annotation">
        <xsl:with-param name="indent">
          <xsl:value-of select="$indent"/>
        </xsl:with-param>
      </xsl:apply-templates>
    </xsl:if>
    <xsl:value-of select="$prefix"/>
    <xsl:apply-templates select="xs:extension/@base"/>
  </xsl:template>
  <xsl:template match="xs:complexContent">
    <xsl:param name="indent"/>
    <xsl:param name="prefix"/>
    <xsl:if test="xs:annotation">
      <xsl:apply-templates select="xs:annotation">
        <xsl:with-param name="indent">
          <xsl:value-of select="$indent"/>
        </xsl:with-param>
      </xsl:apply-templates>
    </xsl:if>
    <xsl:value-of select="$prefix"/>
    <xsl:apply-templates select="xs:extension/@base"/>
  </xsl:template>
  <xsl:template match="xs:complexType">
    <xsl:param name="indent"/>
    <xsl:param name="prefix"/>
    <xsl:param name="choice"/>
    <xsl:if test="xs:annotation">
      <xsl:apply-templates select="xs:annotation">
        <xsl:with-param name="indent">
          <xsl:value-of select="$indent"/>
        </xsl:with-param>
        <xsl:with-param name="choice">
          <xsl:value-of select="$choice"/>
        </xsl:with-param>
      </xsl:apply-templates>
    </xsl:if>
    <xsl:value-of select="$prefix"/>
    <xsl:if test="@name">
      <xsl:value-of select="translate(@name, '-', '_')"/>
      <xsl:text> </xsl:text>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="(xs:simpleContent) or (xs:complexContent)">
        <xsl:apply-templates select="*[not(self::xs:annotation)]">
          <xsl:with-param name="indent">
            <xsl:value-of select="$indent"/>
            <xsl:value-of select="$tab"/>
          </xsl:with-param>
          <xsl:with-param name="choice">
            <xsl:value-of select="$choice"/>
          </xsl:with-param>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>struct {</xsl:text>
        <xsl:choose>
          <xsl:when test="*[not(self::xs:annotation)]">
            <xsl:apply-templates select="*[not(self::xs:annotation)]">
              <xsl:with-param name="indent">
                <xsl:value-of select="$indent"/>
                <xsl:value-of select="$tab"/>
              </xsl:with-param>
            </xsl:apply-templates>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$newline"/>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$indent"/>
        <xsl:text>}</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template match="xs:sequence">
    <xsl:param name="indent"/>
    <xsl:param name="choice"/>
    <xsl:apply-templates select="*[not(self::xs:annotation)]">
      <xsl:with-param name="indent">
        <xsl:value-of select="$indent"/>
      </xsl:with-param>
      <xsl:with-param name="choice">
        <xsl:value-of select="$choice"/>
      </xsl:with-param>
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="xs:group">
    <xsl:param name="indent"/>
    <xsl:param name="choice"/>
    <xsl:param name="prefix"/>
    <xsl:choose>
      <xsl:when test="@name">
        <xsl:value-of select="$indent"/>
        <xsl:value-of select="$prefix"/>
        <xsl:value-of select="translate(@name, '-', '_')"/>
        <xsl:text> </xsl:text>
        <xsl:text>struct {</xsl:text>
        <xsl:apply-templates select="*[not(self::xs:annotation)]">
          <xsl:with-param name="indent">
            <xsl:value-of select="$indent"/>
            <xsl:value-of select="$tab"/>
          </xsl:with-param>
          <xsl:with-param name="choice">
            <xsl:value-of select="$choice"/>
          </xsl:with-param>
        </xsl:apply-templates>
        <xsl:text>}</xsl:text>
      </xsl:when>
      <xsl:when test="@ref">
        <xsl:value-of select="$newline"/>
        <xsl:value-of select="$indent"/>
        <xsl:value-of select="translate(@ref, '-', '_')"/>
        <xsl:value-of select="$newline"/>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
  <xsl:template match="xs:choice">
    <xsl:param name="indent"/>
    <xsl:param name="prefix"/>
    <xsl:apply-templates select="*[not(self::xs:annotation)]">
      <xsl:with-param name="indent">
        <xsl:value-of select="$indent"/>
      </xsl:with-param>
      <xsl:with-param name="prefix">
        <xsl:value-of select="$prefix"/>
      </xsl:with-param>
      <xsl:with-param name="choice">
        <xsl:text>true</xsl:text>
      </xsl:with-param>
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="xs:element/@type | xs:restriction/@base | xs:extension/@base">
    <xsl:choose>
      <xsl:when test=". = 'xs:base64Binary'">
        <xsl:text>XsBase64Binary</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:date'">
        <xsl:text>XsDate</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:decimal'">
        <xsl:text>XsDecimal</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:gYearMonth'">
        <xsl:text>XsGYearMonth</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:float'">
        <xsl:text>XsFloat</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:integer'">
        <xsl:text>XsInteger</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:nonNegativeInteger'">
        <xsl:text>XsNonNegativeInteger</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:nonPositiveInteger'">
        <xsl:text>XsNonPositiveInteger</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:positiveInteger'">
        <xsl:text>XsPositiveInteger</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:string'">
        <xsl:text>XsString</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:time'">
        <xsl:text>XsTime</xsl:text>
      </xsl:when>
      <xsl:when test=". = 'xs:token'">
        <xsl:text>XsToken</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="translate(., '-', '_')"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template match="xs:simpleType" mode="marshal">
    <xsl:text>func (x </xsl:text>
    <xsl:value-of select="translate(@name, '-', '_')"/>
    <xsl:text>) MarshalXML(e *xml.Encoder, start xml.StartElement) error {</xsl:text>
    <xsl:value-of select="$newline"/>
    <xsl:choose>
      <xsl:when test="xs:restriction[@base = 'xs:decimal']/xs:fractionDigits/@value">
        <xsl:value-of select="$tab"/>
        <xsl:text>return e.EncodeElement(fmt.Sprintf("%.</xsl:text>
        <xsl:value-of select="xs:restriction[@base = 'xs:decimal']/xs:fractionDigits/@value"/>
        <xsl:text>f", x), start)</xsl:text>
        <xsl:value-of select="$newline"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$tab"/>
        <xsl:text>return </xsl:text>
        <xsl:apply-templates select="xs:restriction/@base"/>
        <xsl:text>(x).MarshalXML(e, start)</xsl:text>
        <xsl:value-of select="$newline"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>}</xsl:text>
  </xsl:template>
  <xsl:template match="xs:simpleType" mode="unmarshal">
    <xsl:text>func (x *</xsl:text>
    <xsl:value-of select="translate(@name, '-', '_')"/>
    <xsl:text>) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {</xsl:text>
    <xsl:value-of select="$newline"/>
    <xsl:value-of select="$tab"/>
    <xsl:text>var v </xsl:text>
    <xsl:apply-templates select="xs:restriction/@base"/>
    <xsl:value-of select="$newline"/>
    <xsl:value-of select="$tab"/>
    <xsl:text>if err := v.UnmarshalXML(d, start); err != nil {</xsl:text>
    <xsl:value-of select="$newline"/>
    <xsl:value-of select="$tab"/>
    <xsl:value-of select="$tab"/>
    <xsl:text>return err</xsl:text>
    <xsl:value-of select="$newline"/>
    <xsl:value-of select="$tab"/>
    <xsl:text>}</xsl:text>
    <xsl:value-of select="$newline"/>
    <xsl:value-of select="$tab"/>
    <xsl:text>*x = </xsl:text>
    <xsl:value-of select="translate(@name, '-', '_')"/>
    <xsl:text>(v)</xsl:text>
    <xsl:value-of select="$newline"/>
    <xsl:value-of select="$tab"/>
    <xsl:text>return nil</xsl:text>
    <xsl:value-of select="$newline"/>
    <xsl:text>}</xsl:text>
  </xsl:template>
</xsl:stylesheet>
